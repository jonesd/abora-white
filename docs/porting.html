<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
            "http://www.w3.org/TR/html4/loose.dtd">

  <html>

    <head>
      <meta	http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<link rel="stylesheet" type="text/css" href="../style-print.css" media="print"/>
		<link rel="stylesheet" type="text/css" href="../style.css" media="screen"/>

	  <title>Porting Udanax-Gold</title>
    </head>

    <body>
<!-- abora:header -->
		<h1>Porting from Udanax-Gold</h1>
<!-- abora:header_close -->


		<p>In porting Udanax-Gold from Smalltalk to the Java based
		Abora-White a number of issues have come up. For example Smalltalk
			integers are efficiently encoded as object references within 30
			bits or so of size and will transparently expand to large
			integer objects beyond that size, whereas Java int's will not
			expand beyond their max values, and BigIntegers are second-class
			citizens at the syntax level. So what should the Java conversion
			do? The purpose of this page is to document these problems and
			the final outcome I have chosen for Abora-White.</p>

<h3>BooleanVar</h3>

		<p>This was simply replace with the Java <tt>boolean</tt>
			primitive data type.</p>

<h3>IntegerVar</h3>

		<p>The Smalltalk native support for Integers is very powerful. For
			small numbers (< 29(ish) bits) a compact unboxed in-representation form
			is used to minimise performance overhead. If an integer larger
			than the initial range is needed then the system automatically
			changes to a boxed  Integer object format - transparently to the
			application user. The boxed and unboxed versions provide the
			same protocol, and both support C-like operators such as +. The
			only weirdness is that there is no operator precedence rules,
			other than computations start from the left.</p>

		<p>The X++ version of Udanax-Gold seems to support just 32-bit
			integers, which is a surprise. I guess this is either a
			misunderstanding on my part, or perhaps unlimited precision
			support for a pending feature? C++ allows automatic conversions between int and
			IntegerVar class representations.</p>

		<p>The Java native support for integers is split between primitive
			data types of various bit sizes, and the BigInteger class which
			enables unlimited precision integers. There is no automatic
			promotion from primitives to BigInteger. Additionally arithmetic
			operators are supported for the primitive data types, but not
			for BigIntegers.</p>

		<p>Assuming Udanax-Gold IntegerVars are required to support
			unlimited procession, I have temporarily gone for a wrapped
			version of BigInteger. The downsides are performance hits for
			small and large numbers, and no arithmetic operator support. The
			worst of both worlds!</p>

<h3>Java Primitive Data Types</h3>

		<p>The Java primitive data types don't completely match those of
			X++.</p>

		<p>All Java primitives are signed, except for the
			<tt>char</tt> type, this contrasts to X++ where there is full
			control between signed and unsigned. This is particularly
			significant for the UInt32 type which is often used.</p>

		<p>The second case has to do with Strings; Java string characters
			are unsigned 16-bit Unicode, default X++ string characters are unsigned 8-bit.</p>

<h3>Exceptions</h3>

	<p>Udanax-Gold makes extensive use of Exceptions. I believe that on
			the Smalltalk side, the instance based exception mechanism of
			the Smalltalk language is used. On the X++ side I think a custom
			exception mechanism was implemented - possibly done before C++
			exceptions were added to the C++ specification.</p>

	<p>Java supports a reasonable class based exception mechanism. A
			facility beyond the Udanax-Gold exceptions is the support for
			declaring the types of exceptions thrown by a method.</p>

		<p>The initial take is to follow the instance style, and I have
		added a <tt>org.abora.white.exception.AboraRuntimeException</tt>,
			together with a whole bunch of constants extracted from the
			exception use in Udanax-Gold. As the name suggests, this is
			implemented as a Java RuntimeException so that it does not have
			to be included in a methods definition. It is too early to try
			and properly define the relevant throws for each method.</p>

	<p>The pattern for throwing one of these exceptions is like the
			following:<br>
<tt>throw new AboraRuntimeException(AboraRuntimeException.NULL_INSERTION);</tt></p>

		<p>Over time I would like to move to a class based approach, and
			additionally make as much use of the Java built-in exceptions
			where possible.</p>

<h3>Using Steppers</h3>

		<p>When iterating with a Stepper, the Smalltalk version of UG
			naturally uses Smalltalk BlockClosures to pass in the code that
			will be executed for every step. See the #forEach and
			#forPositions method for example implementation.</p>

<pre>	{void} forEach: fn {BlockClosure} 
		[| elem {Heaper} |
		[(elem _ self fetch) ~~ NULL]
			whileTrue:
				[fn value: elem.
				self step]]
			valueNowOrOnUnwindDo: [self destroy]!</pre>

		<p>The X++ translation does not support BlockClosures, so instead
			makes use of the preprocessor define to macros to expand FOR_EACH, or
			whatever, out to the contents of the forEach method for each use
			of it. So there is no forEach method in the X++ source.</p>

		<p>Java has a comparable feature to Smalltalks BlockClosure and so
			could implement and use forEach methods. This would 
			typically be accomplished through the use of Anonymous inner classes
			implementing in this case something like a
			Niladic/Monadic/DuoadicValuable interfaces as needed.
			Unfortunately this technique is often frowned upon in the Java
			community as not matching the standard Java programming style, plus
			the implementation overhead of an extra (hidden) class for each
			<b>use</b> or call.</p>

		<p>Java has no built-in preprocessor support, so the
			behind-the-covers code expansion of the FOR_EACH macro is not
			possible.</p>

		<p>Initially I have decided, again, to follow the worst possible
			route and effectively hand add the contents of the forEach
			method to each use of it. I will review this approach later in
			the project.</p>

		<p>As an example of the Java code for each equivalent forEach call:<br>
<pre>	TableStepper stepper = myArray.stepper();
		try {
			Heaper e;
			while ((e = (Heaper) stepper.fetch()) != null) {
				newArray.atIntStore((myDsp.ofInt(stepper.index())), e);
				stepper.step();
			}
		} finally {
			stepper.destroy();
		}</pre>

		<p>...and the original Smalltalk source:<br>
<pre>	(s _ myArray stepper) forEach: [ :e {Heaper} |
		newArray atInt: (myDsp ofInt: s index) store: e].</pre>

<h3>Object Birth</h3>

		<p>Object creation is usually started by calling a static factory
			method, often named <tt>make</tt>. This can be mapped generally
			to Java. The only complications are that a method defined in a
			subclass whose signature matches that in a superclass can not
			change the return type of the super definition.</p>

		<p>I have used the Java constructors in place of the create
			methods. This generally works out, except that Constructors have
			a number of 'strange' properties in Java. Constructors are not
			inherited, so often I have had to add intervening constructor
			definitions which simply call a super constructor. Following the
			general factor pattern, the constructors are made protected.</p>

		<p>Some open issues in this area are with the area of the
			<tt>new.Become</tt>, and possibly similar methods. Java has not
			capability that matches the Smalltalk become feature. The become
			feature is mapped into two different ways depending on the
			Smalltalk implementation, either one-way or two-way become. A
			one-way become will change all objects referencing object A to
			now reference object B. The two-way become will change all
			object referencing object A to now reference object B <b>and</b>
			for all objects referencing object B to now reference object A.</p>

<h3>Object Death</h3>

		<p>Both Smalltalk and Java have Garbage Collection built in. Java
			additionally supports Weak references and finalization support.
			Newer Smalltalk contain similar features, and it is assumed that
			the Udanax-Gold Smalltalk included these as well.</p>

		<p>C++ doesn't support Garbage Collection in the default
			implementation, and it is assumed that X++ included some kind of
			Garbage Collection system.</p>

		<p>To be researched; is destruct/destroyed only relevant to X++ or
		does it make sense for Smalltalk and Java implementation,
			distributed and file based garbage collection support.</p>

<h3>Equality and Hashing</h3>

		<p>To be researched.</p>

<h3>Casting</h3>

		<p>The <tt>castInto</tt> mechanism is quite extensively used. For
			example:<br>
<pre>	other
		cast: AndFilter into: [:af |
			^af subFilters isEqual: self subFilters]
		others: [^false].</pre>

		<p>This is quite simply hand translated into the following using
			standard Java instanceof operator.<br>
<pre>	if (other instanceof AndFilter) {
		AndFilter af = (AndFilter) other;
		return af.subFilters().isEqual(subFilters());
	} else {
		return false;
	}</pre>

		<p>One case to watch out for is if no <tt>others</tt> section is
			defined. Reading the X++ notes for the comparable
			BEGIN_CHOOSE/BEGIN_KIND/etc feature one sees that in this case
			an exception should be thrown, rather than quietly falling
			through. See <tt>choosex.hxx</tt>.</p>

<h3>Class Instance Variables</h3>

		<p>Smalltalk supports both Class Variables and Class Instance
		Variables. Class Variables effectively match the static fields
		common in C++ and Java. Such a variable is declared in one class,
		and a single value is associated with it that can be shared by all
		subclasses. Class Instance Variables are again declared once in
		association with a class, but the difference is that every
		subclass has its own value bound to the variable.</p>

		<p>Java does not natively support class instance variables, but it
		is relatively straightforward to implement by following the X++
		approach. Declare and define a private static variable in the
		original host of the class instance variable and all its
		subclasses. The static modifier will force each class to have its
		own variable and code will bind to the local classes version, and
		the private access will ensure that code cant use a superclass
		version instead. The only downside is the duplicate definitions
		when it comes to code maintenance.</p>

<h3>Category</h3>

		<p>Udanax-Gold appears to use instances of its Category class to
			support runtime class information. Smalltalk and Java both
			include built-in class objects that are available in a deployed
			runtime application. I assume that C++ of the time didn't,
			together with alternative client languages, which prompted the
			creation of the Category class.</p>

		<p>For the moment the Java Class objects are being used in place
			of Categories. In the future the Category class my need to be
			re-added as more is learnt about its use.</p>

		<p>See: <a href="../udanax-gold2java/abora-gold/api/org/abora/gold/xpp/basic/Category.html">Category API</a>

<h3>Potential Bugs</h3>

		<p>During the course of porting from Udanax-Gold a number of
		potential bugs have been found. This happened by either close
		reading of the code or by creating JUnit tests for the code. I
		felt it was useful to list my discoveries here; to help me later
		when I might run into problems with code relying on this, help
		others who may attempt a port of Udanax-Gold to other systems, and
		for the active readers amongst you to double check my claims and
		hopefully show me that I was wrong.</p>

		<p>I have listed these items as <i>potential</i> bugs as I could
		well be mistaken about the original purpose of the code,
		overlooking details of the Smalltalk/X++ low level implementation
		or quite possible gross user incompetence on my side.</p>

		<p>As a closing statement, I hope nobody takes offence at
		producing such a list, I clearly have great respect for
		Udanax-Gold to even consider spending this amount of time on it,
		and we all know that no reasonable application can be defect
		free.</p>

		<ul>

			<li>PrimIntegerArray:indexPastInteger - when nth is < 0, wont
				find match on index=0 (should have result >= 0)</li>

			<li>Pair:isEqual - throws exception if you use obsolete pairs
				with alternative null values: <tt>(Pair.pairWithNulls(aHeaper,
					null)).isEqual(Pair.pairWithNulls(null, aHeaper))</tt></li>

			<li>MuSet &amp; ImmuSet use incompatible contentsHash mechanisms.
			ActualHashSet adds together element hashes, whereas ImmuSets
			(inherited from ScruSet) bitXor together element hashes. I
			assume this is an oversight rather than a designed, but
			undocumented, mechanism to force Mu/ImmuSet with the same
			elements to produce different contentHashes.</li>

			<li>IntegerRegion:below was actually a duplicate of the above method.</li>

		</ul>

<!-- abora:footer -->
$Id$
<!-- abora:footer_close -->
    </body>
  </html>
